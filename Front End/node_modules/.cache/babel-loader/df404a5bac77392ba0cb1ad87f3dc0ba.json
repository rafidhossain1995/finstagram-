{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst buffer_writer_1 = require(\"./buffer-writer\");\n\nconst writer = new buffer_writer_1.Writer();\n\nconst startup = opts => {\n  // protocol version\n  writer.addInt16(3).addInt16(0);\n\n  for (const key of Object.keys(opts)) {\n    writer.addCString(key).addCString(opts[key]);\n  }\n\n  writer.addCString('client_encoding').addCString('UTF8');\n  var bodyBuffer = writer.addCString('').flush(); // this message is sent without a code\n\n  var length = bodyBuffer.length + 4;\n  return new buffer_writer_1.Writer().addInt32(length).add(bodyBuffer).flush();\n};\n\nconst requestSsl = () => {\n  const response = Buffer.allocUnsafe(8);\n  response.writeInt32BE(8, 0);\n  response.writeInt32BE(80877103, 4);\n  return response;\n};\n\nconst password = password => {\n  return writer.addCString(password).flush(112\n  /* startup */\n  );\n};\n\nconst sendSASLInitialResponseMessage = function (mechanism, initialResponse) {\n  // 0x70 = 'p'\n  writer.addCString(mechanism).addInt32(Buffer.byteLength(initialResponse)).addString(initialResponse);\n  return writer.flush(112\n  /* startup */\n  );\n};\n\nconst sendSCRAMClientFinalMessage = function (additionalData) {\n  return writer.addString(additionalData).flush(112\n  /* startup */\n  );\n};\n\nconst query = text => {\n  return writer.addCString(text).flush(81\n  /* query */\n  );\n};\n\nconst emptyArray = [];\n\nconst parse = query => {\n  // expect something like this:\n  // { name: 'queryName',\n  //   text: 'select * from blah',\n  //   types: ['int8', 'bool'] }\n  // normalize missing query names to allow for null\n  const name = query.name || '';\n\n  if (name.length > 63) {\n    /* eslint-disable no-console */\n    console.error('Warning! Postgres only supports 63 characters for query names.');\n    console.error('You supplied %s (%s)', name, name.length);\n    console.error('This can cause conflicts and silent errors executing queries');\n    /* eslint-enable no-console */\n  }\n\n  const types = query.types || emptyArray;\n  var len = types.length;\n  var buffer = writer.addCString(name) // name of query\n  .addCString(query.text) // actual query text\n  .addInt16(len);\n\n  for (var i = 0; i < len; i++) {\n    buffer.addInt32(types[i]);\n  }\n\n  return writer.flush(80\n  /* parse */\n  );\n};\n\nconst bind = (config = {}) => {\n  // normalize config\n  const portal = config.portal || '';\n  const statement = config.statement || '';\n  const binary = config.binary || false;\n  var values = config.values || emptyArray;\n  var len = values.length;\n  var useBinary = false; // TODO(bmc): all the loops in here aren't nice, we can do better\n\n  for (var j = 0; j < len; j++) {\n    useBinary = useBinary || values[j] instanceof Buffer;\n  }\n\n  var buffer = writer.addCString(portal).addCString(statement);\n\n  if (!useBinary) {\n    buffer.addInt16(0);\n  } else {\n    buffer.addInt16(len);\n\n    for (j = 0; j < len; j++) {\n      buffer.addInt16(values[j] instanceof Buffer ? 1 : 0);\n    }\n  }\n\n  buffer.addInt16(len);\n\n  for (var i = 0; i < len; i++) {\n    var val = values[i];\n\n    if (val === null || typeof val === 'undefined') {\n      buffer.addInt32(-1);\n    } else if (val instanceof Buffer) {\n      buffer.addInt32(val.length);\n      buffer.add(val);\n    } else {\n      buffer.addInt32(Buffer.byteLength(val));\n      buffer.addString(val);\n    }\n  }\n\n  if (binary) {\n    buffer.addInt16(1); // format codes to use binary\n\n    buffer.addInt16(1);\n  } else {\n    buffer.addInt16(0); // format codes to use text\n  }\n\n  return writer.flush(66\n  /* bind */\n  );\n};\n\nconst emptyExecute = Buffer.from([69\n/* execute */\n, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00]);\n\nconst execute = config => {\n  // this is the happy path for most queries\n  if (!config || !config.portal && !config.rows) {\n    return emptyExecute;\n  }\n\n  const portal = config.portal || '';\n  const rows = config.rows || 0;\n  const portalLength = Buffer.byteLength(portal);\n  const len = 4 + portalLength + 1 + 4; // one extra bit for code\n\n  const buff = Buffer.allocUnsafe(1 + len);\n  buff[0] = 69\n  /* execute */\n  ;\n  buff.writeInt32BE(len, 1);\n  buff.write(portal, 5, 'utf-8');\n  buff[portalLength + 5] = 0; // null terminate portal cString\n\n  buff.writeUInt32BE(rows, buff.length - 4);\n  return buff;\n};\n\nconst cancel = (processID, secretKey) => {\n  const buffer = Buffer.allocUnsafe(16);\n  buffer.writeInt32BE(16, 0);\n  buffer.writeInt16BE(1234, 4);\n  buffer.writeInt16BE(5678, 6);\n  buffer.writeInt32BE(processID, 8);\n  buffer.writeInt32BE(secretKey, 12);\n  return buffer;\n};\n\nconst cstringMessage = (code, string) => {\n  const stringLen = Buffer.byteLength(string);\n  const len = 4 + stringLen + 1; // one extra bit for code\n\n  const buffer = Buffer.allocUnsafe(1 + len);\n  buffer[0] = code;\n  buffer.writeInt32BE(len, 1);\n  buffer.write(string, 5, 'utf-8');\n  buffer[len] = 0; // null terminate cString\n\n  return buffer;\n};\n\nconst emptyDescribePortal = writer.addCString('P').flush(68\n/* describe */\n);\nconst emptyDescribeStatement = writer.addCString('S').flush(68\n/* describe */\n);\n\nconst describe = msg => {\n  return msg.name ? cstringMessage(68\n  /* describe */\n  , `${msg.type}${msg.name || ''}`) : msg.type === 'P' ? emptyDescribePortal : emptyDescribeStatement;\n};\n\nconst close = msg => {\n  const text = `${msg.type}${msg.name || ''}`;\n  return cstringMessage(67\n  /* close */\n  , text);\n};\n\nconst copyData = chunk => {\n  return writer.add(chunk).flush(100\n  /* copyFromChunk */\n  );\n};\n\nconst copyFail = message => {\n  return cstringMessage(102\n  /* copyFail */\n  , message);\n};\n\nconst codeOnlyBuffer = code => Buffer.from([code, 0x00, 0x00, 0x00, 0x04]);\n\nconst flushBuffer = codeOnlyBuffer(72\n/* flush */\n);\nconst syncBuffer = codeOnlyBuffer(83\n/* sync */\n);\nconst endBuffer = codeOnlyBuffer(88\n/* end */\n);\nconst copyDoneBuffer = codeOnlyBuffer(99\n/* copyDone */\n);\nconst serialize = {\n  startup,\n  password,\n  requestSsl,\n  sendSASLInitialResponseMessage,\n  sendSCRAMClientFinalMessage,\n  query,\n  parse,\n  bind,\n  execute,\n  describe,\n  close,\n  flush: () => flushBuffer,\n  sync: () => syncBuffer,\n  end: () => endBuffer,\n  copyData,\n  copyDone: () => copyDoneBuffer,\n  copyFail,\n  cancel\n};\nexports.serialize = serialize;","map":{"version":3,"sources":["../src/serializer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst buffer_writer_1 = require(\"./buffer-writer\");\nconst writer = new buffer_writer_1.Writer();\nconst startup = (opts) => {\n    // protocol version\n    writer.addInt16(3).addInt16(0);\n    for (const key of Object.keys(opts)) {\n        writer.addCString(key).addCString(opts[key]);\n    }\n    writer.addCString('client_encoding').addCString('UTF8');\n    var bodyBuffer = writer.addCString('').flush();\n    // this message is sent without a code\n    var length = bodyBuffer.length + 4;\n    return new buffer_writer_1.Writer().addInt32(length).add(bodyBuffer).flush();\n};\nconst requestSsl = () => {\n    const response = Buffer.allocUnsafe(8);\n    response.writeInt32BE(8, 0);\n    response.writeInt32BE(80877103, 4);\n    return response;\n};\nconst password = (password) => {\n    return writer.addCString(password).flush(112 /* startup */);\n};\nconst sendSASLInitialResponseMessage = function (mechanism, initialResponse) {\n    // 0x70 = 'p'\n    writer.addCString(mechanism).addInt32(Buffer.byteLength(initialResponse)).addString(initialResponse);\n    return writer.flush(112 /* startup */);\n};\nconst sendSCRAMClientFinalMessage = function (additionalData) {\n    return writer.addString(additionalData).flush(112 /* startup */);\n};\nconst query = (text) => {\n    return writer.addCString(text).flush(81 /* query */);\n};\nconst emptyArray = [];\nconst parse = (query) => {\n    // expect something like this:\n    // { name: 'queryName',\n    //   text: 'select * from blah',\n    //   types: ['int8', 'bool'] }\n    // normalize missing query names to allow for null\n    const name = query.name || '';\n    if (name.length > 63) {\n        /* eslint-disable no-console */\n        console.error('Warning! Postgres only supports 63 characters for query names.');\n        console.error('You supplied %s (%s)', name, name.length);\n        console.error('This can cause conflicts and silent errors executing queries');\n        /* eslint-enable no-console */\n    }\n    const types = query.types || emptyArray;\n    var len = types.length;\n    var buffer = writer\n        .addCString(name) // name of query\n        .addCString(query.text) // actual query text\n        .addInt16(len);\n    for (var i = 0; i < len; i++) {\n        buffer.addInt32(types[i]);\n    }\n    return writer.flush(80 /* parse */);\n};\nconst bind = (config = {}) => {\n    // normalize config\n    const portal = config.portal || '';\n    const statement = config.statement || '';\n    const binary = config.binary || false;\n    var values = config.values || emptyArray;\n    var len = values.length;\n    var useBinary = false;\n    // TODO(bmc): all the loops in here aren't nice, we can do better\n    for (var j = 0; j < len; j++) {\n        useBinary = useBinary || values[j] instanceof Buffer;\n    }\n    var buffer = writer.addCString(portal).addCString(statement);\n    if (!useBinary) {\n        buffer.addInt16(0);\n    }\n    else {\n        buffer.addInt16(len);\n        for (j = 0; j < len; j++) {\n            buffer.addInt16(values[j] instanceof Buffer ? 1 : 0);\n        }\n    }\n    buffer.addInt16(len);\n    for (var i = 0; i < len; i++) {\n        var val = values[i];\n        if (val === null || typeof val === 'undefined') {\n            buffer.addInt32(-1);\n        }\n        else if (val instanceof Buffer) {\n            buffer.addInt32(val.length);\n            buffer.add(val);\n        }\n        else {\n            buffer.addInt32(Buffer.byteLength(val));\n            buffer.addString(val);\n        }\n    }\n    if (binary) {\n        buffer.addInt16(1); // format codes to use binary\n        buffer.addInt16(1);\n    }\n    else {\n        buffer.addInt16(0); // format codes to use text\n    }\n    return writer.flush(66 /* bind */);\n};\nconst emptyExecute = Buffer.from([69 /* execute */, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00]);\nconst execute = (config) => {\n    // this is the happy path for most queries\n    if (!config || (!config.portal && !config.rows)) {\n        return emptyExecute;\n    }\n    const portal = config.portal || '';\n    const rows = config.rows || 0;\n    const portalLength = Buffer.byteLength(portal);\n    const len = 4 + portalLength + 1 + 4;\n    // one extra bit for code\n    const buff = Buffer.allocUnsafe(1 + len);\n    buff[0] = 69 /* execute */;\n    buff.writeInt32BE(len, 1);\n    buff.write(portal, 5, 'utf-8');\n    buff[portalLength + 5] = 0; // null terminate portal cString\n    buff.writeUInt32BE(rows, buff.length - 4);\n    return buff;\n};\nconst cancel = (processID, secretKey) => {\n    const buffer = Buffer.allocUnsafe(16);\n    buffer.writeInt32BE(16, 0);\n    buffer.writeInt16BE(1234, 4);\n    buffer.writeInt16BE(5678, 6);\n    buffer.writeInt32BE(processID, 8);\n    buffer.writeInt32BE(secretKey, 12);\n    return buffer;\n};\nconst cstringMessage = (code, string) => {\n    const stringLen = Buffer.byteLength(string);\n    const len = 4 + stringLen + 1;\n    // one extra bit for code\n    const buffer = Buffer.allocUnsafe(1 + len);\n    buffer[0] = code;\n    buffer.writeInt32BE(len, 1);\n    buffer.write(string, 5, 'utf-8');\n    buffer[len] = 0; // null terminate cString\n    return buffer;\n};\nconst emptyDescribePortal = writer.addCString('P').flush(68 /* describe */);\nconst emptyDescribeStatement = writer.addCString('S').flush(68 /* describe */);\nconst describe = (msg) => {\n    return msg.name\n        ? cstringMessage(68 /* describe */, `${msg.type}${msg.name || ''}`)\n        : msg.type === 'P'\n            ? emptyDescribePortal\n            : emptyDescribeStatement;\n};\nconst close = (msg) => {\n    const text = `${msg.type}${msg.name || ''}`;\n    return cstringMessage(67 /* close */, text);\n};\nconst copyData = (chunk) => {\n    return writer.add(chunk).flush(100 /* copyFromChunk */);\n};\nconst copyFail = (message) => {\n    return cstringMessage(102 /* copyFail */, message);\n};\nconst codeOnlyBuffer = (code) => Buffer.from([code, 0x00, 0x00, 0x00, 0x04]);\nconst flushBuffer = codeOnlyBuffer(72 /* flush */);\nconst syncBuffer = codeOnlyBuffer(83 /* sync */);\nconst endBuffer = codeOnlyBuffer(88 /* end */);\nconst copyDoneBuffer = codeOnlyBuffer(99 /* copyDone */);\nconst serialize = {\n    startup,\n    password,\n    requestSsl,\n    sendSASLInitialResponseMessage,\n    sendSCRAMClientFinalMessage,\n    query,\n    parse,\n    bind,\n    execute,\n    describe,\n    close,\n    flush: () => flushBuffer,\n    sync: () => syncBuffer,\n    end: () => endBuffer,\n    copyData,\n    copyDone: () => copyDoneBuffer,\n    copyFail,\n    cancel,\n};\nexports.serialize = serialize;\n//# sourceMappingURL=serializer.js.map"]},"metadata":{},"sourceType":"script"}