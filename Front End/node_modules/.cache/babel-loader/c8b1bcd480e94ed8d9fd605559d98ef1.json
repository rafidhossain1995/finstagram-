{"ast":null,"code":"'use strict';\n/**\n * Copyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)\n * All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * README.md file in the root directory of this source tree.\n */\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst Result = require('./result');\n\nconst utils = require('./utils');\n\nclass Query extends EventEmitter {\n  constructor(config, values, callback) {\n    super();\n    config = utils.normalizeQueryConfig(config, values, callback);\n    this.text = config.text;\n    this.values = config.values;\n    this.rows = config.rows;\n    this.types = config.types;\n    this.name = config.name;\n    this.binary = config.binary; // use unique portal name each time\n\n    this.portal = config.portal || '';\n    this.callback = config.callback;\n    this._rowMode = config.rowMode;\n\n    if (process.domain && config.callback) {\n      this.callback = process.domain.bind(config.callback);\n    }\n\n    this._result = new Result(this._rowMode, this.types); // potential for multiple results\n\n    this._results = this._result;\n    this.isPreparedStatement = false;\n    this._canceledDueToError = false;\n    this._promise = null;\n  }\n\n  requiresPreparation() {\n    // named queries must always be prepared\n    if (this.name) {\n      return true;\n    } // always prepare if there are max number of rows expected per\n    // portal execution\n\n\n    if (this.rows) {\n      return true;\n    } // don't prepare empty text queries\n\n\n    if (!this.text) {\n      return false;\n    } // prepare if there are values\n\n\n    if (!this.values) {\n      return false;\n    }\n\n    return this.values.length > 0;\n  }\n\n  _checkForMultirow() {\n    // if we already have a result with a command property\n    // then we've already executed one query in a multi-statement simple query\n    // turn our results into an array of results\n    if (this._result.command) {\n      if (!Array.isArray(this._results)) {\n        this._results = [this._result];\n      }\n\n      this._result = new Result(this._rowMode, this.types);\n\n      this._results.push(this._result);\n    }\n  } // associates row metadata from the supplied\n  // message with this query object\n  // metadata used when parsing row results\n\n\n  handleRowDescription(msg) {\n    this._checkForMultirow();\n\n    this._result.addFields(msg.fields);\n\n    this._accumulateRows = this.callback || !this.listeners('row').length;\n  }\n\n  handleDataRow(msg) {\n    let row;\n\n    if (this._canceledDueToError) {\n      return;\n    }\n\n    try {\n      row = this._result.parseRow(msg.fields);\n    } catch (err) {\n      this._canceledDueToError = err;\n      return;\n    }\n\n    this.emit('row', row, this._result);\n\n    if (this._accumulateRows) {\n      this._result.addRow(row);\n    }\n  }\n\n  handleCommandComplete(msg, con) {\n    this._checkForMultirow();\n\n    this._result.addCommandComplete(msg); // need to sync after each command complete of a prepared statement\n\n\n    if (this.isPreparedStatement) {\n      con.sync();\n    }\n  } // if a named prepared statement is created with empty query text\n  // the backend will send an emptyQuery message but *not* a command complete message\n  // execution on the connection will hang until the backend receives a sync message\n\n\n  handleEmptyQuery(con) {\n    if (this.isPreparedStatement) {\n      con.sync();\n    }\n  }\n\n  handleReadyForQuery(con) {\n    if (this._canceledDueToError) {\n      return this.handleError(this._canceledDueToError, con);\n    }\n\n    if (this.callback) {\n      this.callback(null, this._results);\n    }\n\n    this.emit('end', this._results);\n  }\n\n  handleError(err, connection) {\n    // need to sync after error during a prepared statement\n    if (this.isPreparedStatement) {\n      connection.sync();\n    }\n\n    if (this._canceledDueToError) {\n      err = this._canceledDueToError;\n      this._canceledDueToError = false;\n    } // if callback supplied do not emit error event as uncaught error\n    // events will bubble up to node process\n\n\n    if (this.callback) {\n      return this.callback(err);\n    }\n\n    this.emit('error', err);\n  }\n\n  submit(connection) {\n    if (typeof this.text !== 'string' && typeof this.name !== 'string') {\n      return new Error('A query must have either text or a name. Supplying neither is unsupported.');\n    }\n\n    const previous = connection.parsedStatements[this.name];\n\n    if (this.text && previous && this.text !== previous) {\n      return new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);\n    }\n\n    if (this.values && !Array.isArray(this.values)) {\n      return new Error('Query values must be an array');\n    }\n\n    if (this.requiresPreparation()) {\n      this.prepare(connection);\n    } else {\n      connection.query(this.text);\n    }\n\n    return null;\n  }\n\n  hasBeenParsed(connection) {\n    return this.name && connection.parsedStatements[this.name];\n  }\n\n  handlePortalSuspended(connection) {\n    this._getRows(connection, this.rows);\n  }\n\n  _getRows(connection, rows) {\n    connection.execute({\n      portal: this.portal,\n      rows: rows\n    }, true);\n    connection.flush();\n  }\n\n  prepare(connection) {\n    // prepared statements need sync to be called after each command\n    // complete or when an error is encountered\n    this.isPreparedStatement = true; // TODO refactor this poor encapsulation\n\n    if (!this.hasBeenParsed(connection)) {\n      connection.parse({\n        text: this.text,\n        name: this.name,\n        types: this.types\n      }, true);\n    }\n\n    if (this.values) {\n      try {\n        this.values = this.values.map(utils.prepareValue);\n      } catch (err) {\n        this.handleError(err, connection);\n        return;\n      }\n    } // http://developer.postgresql.org/pgdocs/postgres/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY\n\n\n    connection.bind({\n      portal: this.portal,\n      statement: this.name,\n      values: this.values,\n      binary: this.binary\n    }, true);\n    connection.describe({\n      type: 'P',\n      name: this.portal || ''\n    }, true);\n\n    this._getRows(connection, this.rows);\n  }\n\n  handleCopyInResponse(connection) {\n    connection.sendCopyFail('No source stream defined');\n  } // eslint-disable-next-line no-unused-vars\n\n\n  handleCopyData(msg, connection) {// noop\n  }\n\n}\n\nmodule.exports = Query;","map":{"version":3,"sources":["/Users/rafidhossain/Desktop/Instagram/instagram/Back End/node_modules/pg/lib/query.js"],"names":["EventEmitter","require","Result","utils","Query","constructor","config","values","callback","normalizeQueryConfig","text","rows","types","name","binary","portal","_rowMode","rowMode","process","domain","bind","_result","_results","isPreparedStatement","_canceledDueToError","_promise","requiresPreparation","length","_checkForMultirow","command","Array","isArray","push","handleRowDescription","msg","addFields","fields","_accumulateRows","listeners","handleDataRow","row","parseRow","err","emit","addRow","handleCommandComplete","con","addCommandComplete","sync","handleEmptyQuery","handleReadyForQuery","handleError","connection","submit","Error","previous","parsedStatements","prepare","query","hasBeenParsed","handlePortalSuspended","_getRows","execute","flush","parse","map","prepareValue","statement","describe","type","handleCopyInResponse","sendCopyFail","handleCopyData","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n/**\n * Copyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)\n * All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * README.md file in the root directory of this source tree.\n */\n\nconst { EventEmitter } = require('events')\n\nconst Result = require('./result')\nconst utils = require('./utils')\n\nclass Query extends EventEmitter {\n  constructor(config, values, callback) {\n    super()\n\n    config = utils.normalizeQueryConfig(config, values, callback)\n\n    this.text = config.text\n    this.values = config.values\n    this.rows = config.rows\n    this.types = config.types\n    this.name = config.name\n    this.binary = config.binary\n    // use unique portal name each time\n    this.portal = config.portal || ''\n    this.callback = config.callback\n    this._rowMode = config.rowMode\n    if (process.domain && config.callback) {\n      this.callback = process.domain.bind(config.callback)\n    }\n    this._result = new Result(this._rowMode, this.types)\n\n    // potential for multiple results\n    this._results = this._result\n    this.isPreparedStatement = false\n    this._canceledDueToError = false\n    this._promise = null\n  }\n\n  requiresPreparation() {\n    // named queries must always be prepared\n    if (this.name) {\n      return true\n    }\n    // always prepare if there are max number of rows expected per\n    // portal execution\n    if (this.rows) {\n      return true\n    }\n    // don't prepare empty text queries\n    if (!this.text) {\n      return false\n    }\n    // prepare if there are values\n    if (!this.values) {\n      return false\n    }\n    return this.values.length > 0\n  }\n\n  _checkForMultirow() {\n    // if we already have a result with a command property\n    // then we've already executed one query in a multi-statement simple query\n    // turn our results into an array of results\n    if (this._result.command) {\n      if (!Array.isArray(this._results)) {\n        this._results = [this._result]\n      }\n      this._result = new Result(this._rowMode, this.types)\n      this._results.push(this._result)\n    }\n  }\n\n  // associates row metadata from the supplied\n  // message with this query object\n  // metadata used when parsing row results\n  handleRowDescription(msg) {\n    this._checkForMultirow()\n    this._result.addFields(msg.fields)\n    this._accumulateRows = this.callback || !this.listeners('row').length\n  }\n\n  handleDataRow(msg) {\n    let row\n\n    if (this._canceledDueToError) {\n      return\n    }\n\n    try {\n      row = this._result.parseRow(msg.fields)\n    } catch (err) {\n      this._canceledDueToError = err\n      return\n    }\n\n    this.emit('row', row, this._result)\n    if (this._accumulateRows) {\n      this._result.addRow(row)\n    }\n  }\n\n  handleCommandComplete(msg, con) {\n    this._checkForMultirow()\n    this._result.addCommandComplete(msg)\n    // need to sync after each command complete of a prepared statement\n    if (this.isPreparedStatement) {\n      con.sync()\n    }\n  }\n\n  // if a named prepared statement is created with empty query text\n  // the backend will send an emptyQuery message but *not* a command complete message\n  // execution on the connection will hang until the backend receives a sync message\n  handleEmptyQuery(con) {\n    if (this.isPreparedStatement) {\n      con.sync()\n    }\n  }\n\n  handleReadyForQuery(con) {\n    if (this._canceledDueToError) {\n      return this.handleError(this._canceledDueToError, con)\n    }\n    if (this.callback) {\n      this.callback(null, this._results)\n    }\n    this.emit('end', this._results)\n  }\n\n  handleError(err, connection) {\n    // need to sync after error during a prepared statement\n    if (this.isPreparedStatement) {\n      connection.sync()\n    }\n    if (this._canceledDueToError) {\n      err = this._canceledDueToError\n      this._canceledDueToError = false\n    }\n    // if callback supplied do not emit error event as uncaught error\n    // events will bubble up to node process\n    if (this.callback) {\n      return this.callback(err)\n    }\n    this.emit('error', err)\n  }\n\n  submit(connection) {\n    if (typeof this.text !== 'string' && typeof this.name !== 'string') {\n      return new Error('A query must have either text or a name. Supplying neither is unsupported.')\n    }\n    const previous = connection.parsedStatements[this.name]\n    if (this.text && previous && this.text !== previous) {\n      return new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`)\n    }\n    if (this.values && !Array.isArray(this.values)) {\n      return new Error('Query values must be an array')\n    }\n    if (this.requiresPreparation()) {\n      this.prepare(connection)\n    } else {\n      connection.query(this.text)\n    }\n    return null\n  }\n\n  hasBeenParsed(connection) {\n    return this.name && connection.parsedStatements[this.name]\n  }\n\n  handlePortalSuspended(connection) {\n    this._getRows(connection, this.rows)\n  }\n\n  _getRows(connection, rows) {\n    connection.execute(\n      {\n        portal: this.portal,\n        rows: rows,\n      },\n      true\n    )\n    connection.flush()\n  }\n\n  prepare(connection) {\n    // prepared statements need sync to be called after each command\n    // complete or when an error is encountered\n    this.isPreparedStatement = true\n    // TODO refactor this poor encapsulation\n    if (!this.hasBeenParsed(connection)) {\n      connection.parse(\n        {\n          text: this.text,\n          name: this.name,\n          types: this.types,\n        },\n        true\n      )\n    }\n\n    if (this.values) {\n      try {\n        this.values = this.values.map(utils.prepareValue)\n      } catch (err) {\n        this.handleError(err, connection)\n        return\n      }\n    }\n\n    // http://developer.postgresql.org/pgdocs/postgres/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY\n    connection.bind(\n      {\n        portal: this.portal,\n        statement: this.name,\n        values: this.values,\n        binary: this.binary,\n      },\n      true\n    )\n\n    connection.describe(\n      {\n        type: 'P',\n        name: this.portal || '',\n      },\n      true\n    )\n\n    this._getRows(connection, this.rows)\n  }\n\n  handleCopyInResponse(connection) {\n    connection.sendCopyFail('No source stream defined')\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  handleCopyData(msg, connection) {\n    // noop\n  }\n}\n\nmodule.exports = Query\n"]},"metadata":{},"sourceType":"script"}